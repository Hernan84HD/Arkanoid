<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Cyberpunk Breakout</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000B1E;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            touch-action: none;
            /* Previene scroll en móvil */
        }

        .retro-grid {
            position: absolute;
            width: 200%;
            height: 200%;
            background-image:
                linear-gradient(rgba(0, 255, 255, 0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.2) 1px, transparent 1px);
            background-size: 50px 50px;
            transform: perspective(500px) rotateX(60deg) translateY(-100px) translateZ(-200px);
            animation: gridMove 20s linear infinite;
            z-index: -1;
            pointer-events: none;
        }

        @keyframes gridMove {
            0% {
                transform: perspective(500px) rotateX(60deg) translateY(0) translateZ(-200px);
            }

            100% {
                transform: perspective(500px) rotateX(60deg) translateY(50px) translateZ(-200px);
            }
        }

        #gameCanvas {
            border: 2px solid #00FFFF;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 0, 0, 0.8);
            background-color: rgba(0, 11, 30, 0.85);
            cursor: none;
            backdrop-filter: blur(5px);
            display: block;
        }

        #ui-layer {
            position: absolute;
            pointer-events: none;
            text-align: center;
            width: 100%;
            display: none;
            z-index: 10;
            top: 50%;
            transform: translateY(-50%);
        }

        h1 {
            color: #FF00FF;
            text-shadow: 0 0 15px #FF00FF, 0 0 30px #FF00FF;
            font-size: 3rem;
            /* Adjusted for mobile safety */
            margin-bottom: 10px;
            letter-spacing: 5px;
            text-transform: uppercase;
        }

        p {
            font-size: 1.2rem;
            color: #00FFFF;
            text-shadow: 0 0 10px #00FFFF;
            animation: pulse 1.5s infinite;
        }

        /* Indicador visual para zona táctil */
        #touch-zone-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(0, 255, 255, 0.3);
            font-size: 0.8rem;
            pointer-events: none;
            display: none;
        }

        @media (max-width: 768px) {
            #touch-zone-hint {
                display: block;
            }

            h1 {
                font-size: 2rem;
            }
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }
    </style>
</head>

<body>

    <div class="retro-grid"></div>

    <div id="ui-layer">
        <h1 id="game-title">SYSTEM FAILURE</h1>
        <p>TAP OR PRESS SPACE TO REBOOT</p>
    </div>

    <div id="touch-zone-hint">DESLIZA AQUÍ PARA MOVER</div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('ui-layer');
        const gameTitle = document.getElementById('game-title');

        // Estado del juego
        let isGameOver = false;
        let isPlaying = false; // Nuevo estado para esperar inicio
        let score = 0;

        // Entidades
        let ball = { x: 0, y: 0, dx: 0, dy: 0, radius: 6 };
        let paddle = { x: 0, width: 100, height: 12 };
        let bricks = [];
        let particles = [];
        let ballTrail = [];

        // Configuración estética
        const brickPadding = 10;
        const brickOffsetTop = 60;
        const trailLength = 10;

        // Inputs
        let rightPressed = false;
        let leftPressed = false;

        // --- Redimensionado y Adaptabilidad ---
        function resizeCanvas() {
            // Ajustar al tamaño de la ventana
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Ajustar paleta para móviles
            if (canvas.width < 500) {
                paddle.width = 80;
            } else {
                paddle.width = 100;
            }

            // Reiniciar si estamos en medio de juego o menú para ajustar posiciones
            if (!isPlaying) {
                resetBallPaddle();
            }
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            // Si no estamos jugando, reinicializar ladrillos para ajustar columnas
            if (!isPlaying) {
                initGame();
            }
        });

        // --- Inicialización ---

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.size = Math.random() * 3 + 1;
                this.speedX = Math.random() * 6 - 3;
                this.speedY = Math.random() * 6 - 3;
                this.life = 1.0; this.decay = Math.random() * 0.02 + 0.01;
            }
            update() { this.x += this.speedX; this.y += this.speedY; this.life -= this.decay; }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.rect(this.x, this.y, this.size, this.size);
                ctx.fill(); ctx.restore();
            }
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) { particles.push(new Particle(x, y, color)); }
        }

        function resetBallPaddle() {
            paddle.x = (canvas.width - paddle.width) / 2;
            ball.x = canvas.width / 2;
            ball.y = canvas.height - 40;
            ball.dx = 0;
            ball.dy = 0;
            ballTrail = [];
        }

        function initGame() {
            isPlaying = false;
            isGameOver = false;
            score = 0;
            uiLayer.style.display = 'block';
            gameTitle.innerText = "NEON BREAKOUT";

            resetBallPaddle();

            // Calcular columnas dinámicamente según ancho
            let brickColumnCount = Math.floor((canvas.width - 40) / 70); // ~70px por ladrillo
            brickColumnCount = Math.max(3, Math.min(brickColumnCount, 12)); // Min 3, Max 12

            const brickRowCount = 5;
            const totalBrickWidth = canvas.width - (brickPadding * (brickColumnCount - 1)) - 40; // 20px padding lados
            const brickWidth = totalBrickWidth / brickColumnCount;
            const brickOffsetLeft = 20;

            const rowColors = ["#FF00FF", "#FFFF00", "#00FF00", "#00FFFF", "#FF0055"];

            bricks = [];
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = {
                        x: (c * (brickWidth + brickPadding)) + brickOffsetLeft,
                        y: (r * (20 + brickPadding)) + brickOffsetTop,
                        status: 1,
                        color: rowColors[r % rowColors.length],
                        w: brickWidth, h: 20
                    };
                }
            }
        }

        function startGame() {
            if (!isPlaying && !isGameOver) {
                isPlaying = true;
                uiLayer.style.display = 'none';
                const speed = canvas.width < 500 ? 5 : 7; // Más lento en pantallas pequeñas
                ball.dx = speed * (Math.random() > 0.5 ? 1 : -1);
                ball.dy = -speed;
            } else if (isGameOver) {
                initGame();
            }
        }

        // --- Inputs ---
        // Teclado
        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);

        function keyDownHandler(e) {
            if (e.key == "Right" || e.key == "ArrowRight") rightPressed = true;
            else if (e.key == "Left" || e.key == "ArrowLeft") leftPressed = true;
            else if (e.code == "Space") startGame();
        }
        function keyUpHandler(e) {
            if (e.key == "Right" || e.key == "ArrowRight") rightPressed = false;
            else if (e.key == "Left" || e.key == "ArrowLeft") leftPressed = false;
        }

        // Touch (Mobile)
        canvas.addEventListener("touchstart", touchHandler, { passive: false });
        canvas.addEventListener("touchmove", touchHandler, { passive: false });
        document.addEventListener("click", startGame); // Click para empezar también

        function touchHandler(e) {
            // Solo para empezar si estamos en menú
            if (!isPlaying || isGameOver) {
                startGame();
                e.preventDefault();
                return;
            }

            if (e.touches && e.touches.length > 0) {
                const touchX = e.touches[0].clientX;
                // Mover paleta directamente a la posición X del dedo
                let relativeX = touchX - canvas.offsetLeft;
                if (relativeX > 0 && relativeX < canvas.width) {
                    // Centrar paleta en dedo
                    paddle.x = relativeX - paddle.width / 2;
                }
                e.preventDefault(); // Prevenir scroll
            }
        }

        // Mouse (Backup)
        document.addEventListener("mousemove", mouseMoveHandler, false);
        function mouseMoveHandler(e) {
            if (!isPlaying) return;
            const relativeX = e.clientX - canvas.offsetLeft;
            if (relativeX > 0 && relativeX < canvas.width) {
                paddle.x = relativeX - paddle.width / 2;
            }
        }

        // --- Lógica Principal ---
        function update() {
            // Movimiento Paleta (Teclado)
            if (rightPressed && paddle.x < canvas.width - paddle.width) {
                paddle.x += 8;
            }
            else if (leftPressed && paddle.x > 0) {
                paddle.x -= 8;
            }

            // Límites paleta
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

            if (!isPlaying) return;

            // Movimiento Pelota
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Rebotes
            if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                ball.dx = -ball.dx;
            }
            if (ball.y + ball.dy < ball.radius) {
                ball.dy = -ball.dy;
            } else if (ball.y + ball.dy > canvas.height - paddle.height - ball.radius) {
                // Colisión paleta
                if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                    let collidePoint = ball.x - (paddle.x + paddle.width / 2);
                    collidePoint = collidePoint / (paddle.width / 2);
                    let angle = collidePoint * (Math.PI / 3);

                    let currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    currentSpeed = Math.min(currentSpeed * 1.05, 15);

                    ball.dx = currentSpeed * Math.sin(angle);
                    ball.dy = -currentSpeed * Math.cos(angle);
                }
            }

            if (ball.y + ball.dy > canvas.height) {
                endGame("SYSTEM FAILURE");
            }

            // Colisión Ladrillos
            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        if (ball.x > b.x && ball.x < b.x + b.w && ball.y > b.y && ball.y < b.y + b.h) {
                            ball.dy = -ball.dy;
                            b.status = 0;
                            score++;
                            createExplosion(b.x + b.w / 2, b.y + b.h / 2, b.color);

                            // Check Win (Simplificado para array dinámico)
                            // ... se podría optimizar llevando cuenta de ladrillos totales
                        }
                    }
                }
            }
        }

        function endGame(msg) {
            isGameOver = true;
            isPlaying = false;
            gameTitle.innerText = msg;
            uiLayer.style.display = 'block';
        }

        // --- Dibujado ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Fondo transparente para ver grid detrás si quisiera, pero tengo bg opacity

            // Pelota y Trail
            if (isPlaying) {
                ballTrail.push({ x: ball.x, y: ball.y });
                if (ballTrail.length > trailLength) ballTrail.shift();
            }

            ballTrail.forEach((pos, i) => {
                const opacity = (i + 1) / ballTrail.length;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, ball.radius * (opacity * 0.8), 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 255, 255, ${opacity * 0.5})`;
                ctx.fill();
            });

            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#fff";
            ctx.shadowBlur = 15; ctx.shadowColor = "#00FFFF";
            ctx.fill();
            ctx.shadowBlur = 0;

            // Paleta
            ctx.beginPath();
            ctx.fillStyle = "#000";
            ctx.strokeStyle = "#FF00FF";
            ctx.lineWidth = 2;
            ctx.rect(paddle.x, canvas.height - paddle.height - 5, paddle.width, paddle.height);
            ctx.stroke();
            ctx.fillStyle = "rgba(255, 0, 255, 0.3)";
            ctx.fill();
            ctx.shadowBlur = 0;

            // Ladrillos
            bricks.forEach(col => {
                col.forEach(b => {
                    if (b.status === 1) {
                        ctx.beginPath();
                        ctx.rect(b.x, b.y, b.w, b.h);
                        ctx.fillStyle = b.color;
                        ctx.shadowBlur = 10; ctx.shadowColor = b.color;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = "rgba(255,255,255,0.3)";
                        ctx.fillRect(b.x + 2, b.y + 2, b.w - 4, b.h - 4);
                    }
                });
            });

            // Partículas
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw(ctx);
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            // Score
            ctx.font = "20px 'Orbitron'";
            ctx.fillStyle = "#00FF00";
            ctx.fillText("SCORE: " + score, 20, 40);

            update();
            requestAnimationFrame(draw);
        }

        // Arranque inicial para ajustar tamaños
        resizeCanvas();
        initGame();
        draw(); // Loop de dibujado continuo

    </script>
</body>

</html>